// Code generated by protoc-gen-go. DO NOT EDIT.
// source: demo.proto

// 包名定义, Python中使用时可以省略不写
// Package name definition, which can be omitted in Python.

package demo

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

//
//`message` is used to define the structure of the data to be transmitted, after the equal sign
//is the field number. Each field in the message definition has a unique number.
//The overall format is similar to defining a class in Python or a structure in Golang.
type Request struct {
	ClientId             int64    `protobuf:"varint,1,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
	RequestData          string   `protobuf:"bytes,2,opt,name=request_data,json=requestData,proto3" json:"request_data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Request) Reset()         { *m = Request{} }
func (m *Request) String() string { return proto.CompactTextString(m) }
func (*Request) ProtoMessage()    {}
func (*Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca53982754088a9d, []int{0}
}

func (m *Request) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Request.Unmarshal(m, b)
}
func (m *Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Request.Marshal(b, m, deterministic)
}
func (m *Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request.Merge(m, src)
}
func (m *Request) XXX_Size() int {
	return xxx_messageInfo_Request.Size(m)
}
func (m *Request) XXX_DiscardUnknown() {
	xxx_messageInfo_Request.DiscardUnknown(m)
}

var xxx_messageInfo_Request proto.InternalMessageInfo

func (m *Request) GetClientId() int64 {
	if m != nil {
		return m.ClientId
	}
	return 0
}

func (m *Request) GetRequestData() string {
	if m != nil {
		return m.RequestData
	}
	return ""
}

type Response struct {
	ServerId             int64    `protobuf:"varint,1,opt,name=server_id,json=serverId,proto3" json:"server_id,omitempty"`
	ResponseData         string   `protobuf:"bytes,2,opt,name=response_data,json=responseData,proto3" json:"response_data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Response) Reset()         { *m = Response{} }
func (m *Response) String() string { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()    {}
func (*Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca53982754088a9d, []int{1}
}

func (m *Response) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Response.Unmarshal(m, b)
}
func (m *Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Response.Marshal(b, m, deterministic)
}
func (m *Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response.Merge(m, src)
}
func (m *Response) XXX_Size() int {
	return xxx_messageInfo_Response.Size(m)
}
func (m *Response) XXX_DiscardUnknown() {
	xxx_messageInfo_Response.DiscardUnknown(m)
}

var xxx_messageInfo_Response proto.InternalMessageInfo

func (m *Response) GetServerId() int64 {
	if m != nil {
		return m.ServerId
	}
	return 0
}

func (m *Response) GetResponseData() string {
	if m != nil {
		return m.ResponseData
	}
	return ""
}

func init() {
	proto.RegisterType((*Request)(nil), "demo.Request")
	proto.RegisterType((*Response)(nil), "demo.Response")
}

func init() { proto.RegisterFile("demo.proto", fileDescriptor_ca53982754088a9d) }

var fileDescriptor_ca53982754088a9d = []byte{
	// 239 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x91, 0xc1, 0x4a, 0x03, 0x31,
	0x10, 0x86, 0x89, 0x8a, 0x6e, 0xc7, 0xad, 0x87, 0x80, 0x50, 0xd4, 0x43, 0xad, 0x97, 0xbd, 0x58,
	0x8a, 0x5e, 0xbc, 0x6a, 0x0b, 0xb2, 0xa0, 0x20, 0xd9, 0x07, 0x28, 0xb1, 0x19, 0x34, 0xb0, 0x49,
	0xd6, 0x64, 0xf4, 0xb9, 0x7d, 0x04, 0x49, 0x36, 0x85, 0x3d, 0xba, 0xb7, 0xe4, 0x63, 0xfe, 0x6f,
	0xfe, 0x10, 0x00, 0x85, 0xc6, 0x2d, 0x3b, 0xef, 0xc8, 0xf1, 0xa3, 0x78, 0x5e, 0xd4, 0x70, 0x22,
	0xf0, 0xeb, 0x1b, 0x03, 0xf1, 0x4b, 0x98, 0xec, 0x5a, 0x8d, 0x96, 0xb6, 0x5a, 0xcd, 0xd8, 0x9c,
	0x55, 0x87, 0xa2, 0xe8, 0x41, 0xad, 0xf8, 0x35, 0x94, 0xbe, 0x9f, 0xdb, 0x2a, 0x49, 0x72, 0x76,
	0x30, 0x67, 0xd5, 0x44, 0x9c, 0x66, 0xb6, 0x91, 0x24, 0x17, 0x2f, 0x50, 0x08, 0x0c, 0x9d, 0xb3,
	0x01, 0xa3, 0x2b, 0xa0, 0xff, 0x41, 0x3f, 0x70, 0xf5, 0xa0, 0x56, 0xfc, 0x06, 0xa6, 0x3e, 0x0f,
	0x0e, 0x65, 0xe5, 0x1e, 0x46, 0xdb, 0xdd, 0x2f, 0x83, 0xe2, 0x59, 0xbc, 0xad, 0x37, 0x68, 0x1c,
	0xbf, 0x85, 0xb2, 0xd1, 0xa6, 0x6b, 0xf1, 0x15, 0xe9, 0xd3, 0x29, 0x3e, 0x5d, 0xa6, 0x87, 0xe4,
	0xe6, 0x17, 0x67, 0xfb, 0x6b, 0xde, 0xfe, 0x00, 0xe7, 0xeb, 0x54, 0xbc, 0x21, 0x8f, 0xd2, 0x68,
	0xfb, 0xf1, 0xaf, 0x5c, 0xc5, 0x62, 0xb2, 0x49, 0x35, 0xc7, 0x25, 0x57, 0x8c, 0x3f, 0xc2, 0xd5,
	0x93, 0x56, 0xda, 0xe3, 0x8e, 0xb4, 0xb3, 0xb2, 0x1d, 0xbb, 0x7a, 0xc5, 0xde, 0x8f, 0xd3, 0xc7,
	0xdc, 0xff, 0x05, 0x00, 0x00, 0xff, 0xff, 0x58, 0x68, 0xb4, 0xbb, 0xa6, 0x01, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// GRPCDemoClient is the client API for GRPCDemo service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type GRPCDemoClient interface {
	// 一元模式(在一次调用中, 客户端只能向服务器传输一次请求数据, 服务器也只能返回一次响应)
	// unary-unary(In a single call, the client can only send request once, and the server can
	// only respond once.)
	SimpleMethod(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error)
	// 客户端流模式（在一次调用中, 客户端可以多次向服务器传输数据, 但是服务器只能返回一次响应）
	// stream-unary (In a single call, the client can transfer data to the server several times,
	// but the server can only return a response once.)
	ClientStreamingMethod(ctx context.Context, opts ...grpc.CallOption) (GRPCDemo_ClientStreamingMethodClient, error)
	// 服务端流模式（在一次调用中, 客户端只能一次向服务器传输数据, 但是服务器可以多次返回响应）
	// unary-stream (In a single call, the client can only transmit data to the server at one time,
	// but the server can return the response many times.)
	ServerStreamingMethod(ctx context.Context, in *Request, opts ...grpc.CallOption) (GRPCDemo_ServerStreamingMethodClient, error)
	// 双向流模式 (在一次调用中, 客户端和服务器都可以向对方多次收发数据)
	// stream-stream (In a single call, both client and server can send and receive data
	// to each other multiple times.)
	BidirectionalStreamingMethod(ctx context.Context, opts ...grpc.CallOption) (GRPCDemo_BidirectionalStreamingMethodClient, error)
}

type gRPCDemoClient struct {
	cc *grpc.ClientConn
}

func NewGRPCDemoClient(cc *grpc.ClientConn) GRPCDemoClient {
	return &gRPCDemoClient{cc}
}

func (c *gRPCDemoClient) SimpleMethod(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/demo.GRPCDemo/SimpleMethod", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gRPCDemoClient) ClientStreamingMethod(ctx context.Context, opts ...grpc.CallOption) (GRPCDemo_ClientStreamingMethodClient, error) {
	stream, err := c.cc.NewStream(ctx, &_GRPCDemo_serviceDesc.Streams[0], "/demo.GRPCDemo/ClientStreamingMethod", opts...)
	if err != nil {
		return nil, err
	}
	x := &gRPCDemoClientStreamingMethodClient{stream}
	return x, nil
}

type GRPCDemo_ClientStreamingMethodClient interface {
	Send(*Request) error
	CloseAndRecv() (*Response, error)
	grpc.ClientStream
}

type gRPCDemoClientStreamingMethodClient struct {
	grpc.ClientStream
}

func (x *gRPCDemoClientStreamingMethodClient) Send(m *Request) error {
	return x.ClientStream.SendMsg(m)
}

func (x *gRPCDemoClientStreamingMethodClient) CloseAndRecv() (*Response, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Response)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *gRPCDemoClient) ServerStreamingMethod(ctx context.Context, in *Request, opts ...grpc.CallOption) (GRPCDemo_ServerStreamingMethodClient, error) {
	stream, err := c.cc.NewStream(ctx, &_GRPCDemo_serviceDesc.Streams[1], "/demo.GRPCDemo/ServerStreamingMethod", opts...)
	if err != nil {
		return nil, err
	}
	x := &gRPCDemoServerStreamingMethodClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type GRPCDemo_ServerStreamingMethodClient interface {
	Recv() (*Response, error)
	grpc.ClientStream
}

type gRPCDemoServerStreamingMethodClient struct {
	grpc.ClientStream
}

func (x *gRPCDemoServerStreamingMethodClient) Recv() (*Response, error) {
	m := new(Response)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *gRPCDemoClient) BidirectionalStreamingMethod(ctx context.Context, opts ...grpc.CallOption) (GRPCDemo_BidirectionalStreamingMethodClient, error) {
	stream, err := c.cc.NewStream(ctx, &_GRPCDemo_serviceDesc.Streams[2], "/demo.GRPCDemo/BidirectionalStreamingMethod", opts...)
	if err != nil {
		return nil, err
	}
	x := &gRPCDemoBidirectionalStreamingMethodClient{stream}
	return x, nil
}

type GRPCDemo_BidirectionalStreamingMethodClient interface {
	Send(*Request) error
	Recv() (*Response, error)
	grpc.ClientStream
}

type gRPCDemoBidirectionalStreamingMethodClient struct {
	grpc.ClientStream
}

func (x *gRPCDemoBidirectionalStreamingMethodClient) Send(m *Request) error {
	return x.ClientStream.SendMsg(m)
}

func (x *gRPCDemoBidirectionalStreamingMethodClient) Recv() (*Response, error) {
	m := new(Response)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// GRPCDemoServer is the server API for GRPCDemo service.
type GRPCDemoServer interface {
	// 一元模式(在一次调用中, 客户端只能向服务器传输一次请求数据, 服务器也只能返回一次响应)
	// unary-unary(In a single call, the client can only send request once, and the server can
	// only respond once.)
	SimpleMethod(context.Context, *Request) (*Response, error)
	// 客户端流模式（在一次调用中, 客户端可以多次向服务器传输数据, 但是服务器只能返回一次响应）
	// stream-unary (In a single call, the client can transfer data to the server several times,
	// but the server can only return a response once.)
	ClientStreamingMethod(GRPCDemo_ClientStreamingMethodServer) error
	// 服务端流模式（在一次调用中, 客户端只能一次向服务器传输数据, 但是服务器可以多次返回响应）
	// unary-stream (In a single call, the client can only transmit data to the server at one time,
	// but the server can return the response many times.)
	ServerStreamingMethod(*Request, GRPCDemo_ServerStreamingMethodServer) error
	// 双向流模式 (在一次调用中, 客户端和服务器都可以向对方多次收发数据)
	// stream-stream (In a single call, both client and server can send and receive data
	// to each other multiple times.)
	BidirectionalStreamingMethod(GRPCDemo_BidirectionalStreamingMethodServer) error
}

// UnimplementedGRPCDemoServer can be embedded to have forward compatible implementations.
type UnimplementedGRPCDemoServer struct {
}

func (*UnimplementedGRPCDemoServer) SimpleMethod(ctx context.Context, req *Request) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SimpleMethod not implemented")
}
func (*UnimplementedGRPCDemoServer) ClientStreamingMethod(srv GRPCDemo_ClientStreamingMethodServer) error {
	return status.Errorf(codes.Unimplemented, "method ClientStreamingMethod not implemented")
}
func (*UnimplementedGRPCDemoServer) ServerStreamingMethod(req *Request, srv GRPCDemo_ServerStreamingMethodServer) error {
	return status.Errorf(codes.Unimplemented, "method ServerStreamingMethod not implemented")
}
func (*UnimplementedGRPCDemoServer) BidirectionalStreamingMethod(srv GRPCDemo_BidirectionalStreamingMethodServer) error {
	return status.Errorf(codes.Unimplemented, "method BidirectionalStreamingMethod not implemented")
}

func RegisterGRPCDemoServer(s *grpc.Server, srv GRPCDemoServer) {
	s.RegisterService(&_GRPCDemo_serviceDesc, srv)
}

func _GRPCDemo_SimpleMethod_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GRPCDemoServer).SimpleMethod(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/demo.GRPCDemo/SimpleMethod",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GRPCDemoServer).SimpleMethod(ctx, req.(*Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _GRPCDemo_ClientStreamingMethod_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GRPCDemoServer).ClientStreamingMethod(&gRPCDemoClientStreamingMethodServer{stream})
}

type GRPCDemo_ClientStreamingMethodServer interface {
	SendAndClose(*Response) error
	Recv() (*Request, error)
	grpc.ServerStream
}

type gRPCDemoClientStreamingMethodServer struct {
	grpc.ServerStream
}

func (x *gRPCDemoClientStreamingMethodServer) SendAndClose(m *Response) error {
	return x.ServerStream.SendMsg(m)
}

func (x *gRPCDemoClientStreamingMethodServer) Recv() (*Request, error) {
	m := new(Request)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _GRPCDemo_ServerStreamingMethod_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Request)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GRPCDemoServer).ServerStreamingMethod(m, &gRPCDemoServerStreamingMethodServer{stream})
}

type GRPCDemo_ServerStreamingMethodServer interface {
	Send(*Response) error
	grpc.ServerStream
}

type gRPCDemoServerStreamingMethodServer struct {
	grpc.ServerStream
}

func (x *gRPCDemoServerStreamingMethodServer) Send(m *Response) error {
	return x.ServerStream.SendMsg(m)
}

func _GRPCDemo_BidirectionalStreamingMethod_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GRPCDemoServer).BidirectionalStreamingMethod(&gRPCDemoBidirectionalStreamingMethodServer{stream})
}

type GRPCDemo_BidirectionalStreamingMethodServer interface {
	Send(*Response) error
	Recv() (*Request, error)
	grpc.ServerStream
}

type gRPCDemoBidirectionalStreamingMethodServer struct {
	grpc.ServerStream
}

func (x *gRPCDemoBidirectionalStreamingMethodServer) Send(m *Response) error {
	return x.ServerStream.SendMsg(m)
}

func (x *gRPCDemoBidirectionalStreamingMethodServer) Recv() (*Request, error) {
	m := new(Request)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _GRPCDemo_serviceDesc = grpc.ServiceDesc{
	ServiceName: "demo.GRPCDemo",
	HandlerType: (*GRPCDemoServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SimpleMethod",
			Handler:    _GRPCDemo_SimpleMethod_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ClientStreamingMethod",
			Handler:       _GRPCDemo_ClientStreamingMethod_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "ServerStreamingMethod",
			Handler:       _GRPCDemo_ServerStreamingMethod_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "BidirectionalStreamingMethod",
			Handler:       _GRPCDemo_BidirectionalStreamingMethod_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "demo.proto",
}
